# 2장 올림픽 통계 서비스 최적화

### 학습할 최적화 기법

- CSS 애니메이션 최적화
- 컴포넌트 지연 로딩
- 컴포넌트 사전 로딩
- 이미지 사전 로딩

-----------

이 서비스는 리우 올림픽과 런던 올림픽을 비교하는 단일 페이지로 이루어져 있는 사이트이다.

![img.png](img.png)


### 문제점

#### 첫번째

하단에 올림픽 사진 이라는 버튼을 누르면 사진이 로드되기 전에 모달이 이상한 형태로 깨져있다가 생긴다.

네트워크에서 Fast 3G , Disabled Cache 를 사용하면 상황은 좀 더 좋지 않아진다.

이것만 볼 경우에는 사진 사이즈가 너무 커서 늦게 로드되는 것으로 추측할 수 있다.

#### 두번쨰

올림픽 사진 보기 버튼 아래에는 설문 결과 항목이 있다. 설문 겨롸는 막대 그래프로 표시되어 있고

하나의 항목을 클릭하면 해당 답변에 응답한 사람들에 대해서 필터링을 하여 그래프를 다시 보여준다.

이 때 막대 길이의 애니메이션을 보여주는데 자연스럽지 않은 모습을 보여준다.

-----------------

## Image

```typescript
{showModal ? <ImageModal closeModal={() => { setShowModal(false) }} /> : null}
```

showModal Boolean 값으로 ImageModal 을 렌더링 시키고 있다는걸 알 수 있다.

ImageModal 컴포넌트에서 중점으로 봐야할 것

- react-image-gallery 라이브러리 사용
- 라이브러리에 이미지 데이터를 넘겨 화면에 표시 중

외부 라이르러리를 사용한다는 것은 해당 라이브러리의 사이즈만큼 최정 번들링된 자바스크립트의 사이즈가 커지는 것

이미지 자체를 로드하는데 시간이 걸려 사용자에게 늦게 보일수도 있고 더 중요한 리소스를 로드하는 것을 방해할 수도 있다.

--------------------

## Bar

Bar 컴포넌트에서는 막대 그래프와 텍스트를 그리기 위한 요소들이 있다.

styled-components 를 이용해서 구현한 바 그래프와 width, transtion 속성이다.

percent 값이 바뀌면 width 값이 같이 바뀌면서 transition 속성에 의해 애니메이션이 일어난다.


------------------

## 애니메이션 최적화

설문 결과 영역에 들어간 애니메이션에 대한 최적화를 교재에서 첫 번쨰 내용으로 남겼다.

설문 항목을 클릭하면 해당 응답에 대해 필터링되고 막대 그래프의 배경 그래프의 배경 색과 막대의 가로 길이가 변한다.

하지만 이 애니메이션은 부드럽게 늘어나지 않고 살짝 끊긴다고 한다.

이런 현상이 쟁크(jank) 라고 한다. 왜 이런 현상이 일어나는가?

이 현상을 이해하려면 어떻게 화면을 그리는지 알아야 한다.


8FPS 의 애니메이션을 보여줄 떄 8장의 사진을 순서대로 보여줘야 하는데 만약 한 장의 이미지가 빠진다면 어떻게 될까?

어색하게 끊기는 부분이 있을 것이다.

### 브라우저 렌더링 과정

브라우저는 DOM + CSSOM > 렌더 트리 > 레이아웃 > 페인트 > 컴포지트 이 과정을 거쳐서 화면을 그린다.

주요 렌더링 경로 또는 픽셀 파이프라인 이라고 한다.

### DOM + CSSOM

가장 처음에는 HTML 파일과 CSS 등 화면을 그리는데 필요한 리소스를 다운로드

다운로드한 파일을 브라우저가 이해할 수 있는 형태로 변환하는 파싱 과정을 거친다. 요소간의 관계가 트리 구조로 표현되어 있는 DOM 을 만든다.

CSS 또한 비슷한 과정을 거쳐 브라우저가 이해할 수 있는 형태로 변환된다.

### 렌더 트리

렌더 트리는 DOM 과 CSSOM 의 결합으로 생성된다. 렌더 트리는 화면에 표시되는 각 요소의 레이아웃을 계산하는데 사용된다.

### 레이아웃 

렌더 트리가 완성이 되면 레이아웃 단계로 넘어간다. 이 레이아웃 단계에서는 위치와 크기를 계산하고 해당 위치에 요소를 배치하는 작업을 한다.

### 페인트

화면의 요소의 위치와 크기를 잡아 놨으니 화면에 배치된 요소에 색을 채워넣는 작업을 한다.

예를 들어 배경 색을 채워 넣거나 글자 색을 결정하거나 테두리 색을 변경한다.

### 컴포지드

컴포지드 단계는 각 레이어를 합성하는 작업을 한다.

페인트 단계에서 설명한 것처럼 브라우저는 화면을 그릴 떄 여러 개의 레이어로 화면을 쪼개서 그린다.

레이어를 하나로 합성하는 단계. 컴포지드 단계이다.

브라우저 렌더링 과정을 살펴본다. 이 과정을 브라우저에서 직접 확인해 볼 수 있다.

![img_1.png](img_1.png)

나같은 경우는 점선은 찾지 못했다. 다만 위에 있는 내용이 맞지 않나 싶은데?

화면이 전부 그려진 후 설문 결과에서 애니메이션처럼 일부 요소의 스타일을 변경하거나 추가 제거하면 다시한번 그리는 행동

**리페인트, 리플로우가 일어난다**

### 리플로우와 리페인트

렌더링 경로에 대입해 보면 먼저 요소의 스타일이 변했기 떄문에 CSSOM을 다시 만들어야 한다.

CSSOM 을 이용하여 새로운 렌더 트리를 만든다.

처음부터 알맞게 색을 칠하고 분할된 레이어를 하나로 컴포지드한다. 이것을 리플로우라 한다.

그냥 처음부터 끝까지 다시한다. 그로인해 브라우저 리소스를 많이 사용한다.

스타일 속성이 변경되었기 때문에 CSSOM 이 새롭게 생성되고 렌더 트리도 새로 만들어진다.

하지만 레이아웃 단계는 실행되지 않는다. 요소의 위치나 크기에는 영향이 가지 않기 떄문이다.

바로 색을 입히는 페인트, 컴포지드 단계로 이동된다. 이것을 리페인트라 한다.

이것을 피하기 위해서 transform, opacity 같은 속성을 사용하는 방법이 있다.

**해당 요소를 별도의 레이어로 분리하고 작업을 GPU에 위임하여 처리할 수 있다. 레이아웃 단계와 페인트 단계를 건너뛸 수 있다.**

이것을 **하드웨어 가속** 이라한다.

### 하드웨어 가속

하드웨어 가속은 CPU 에서 처리해야 할 작업을 GPU에 위임하여 더욱 효율적으로 처리하는 방법을 말한다.

특정 요소에 하드웨어 가속을 사용하려면 요소를 별도의 레이어를 분리하여 GPU로 보내야 하는데

앞서 말한 transform, opacity 두 옵션이 이 역할을 한다.

width, height, color 등의 속성이 아닌 transform, opacity 이용한 애니메이션 성능이 좋을 수 밖에 없다.

------

### 애니메이션 최적화

문제의 원인과 해결 방법을 알았으니 리플로우를 -> 리페인트로 바꾸면 된다.

```javascript
const BarGraph = styled.div`
    position: absolute;
    left: 0;
    top: 0;
    height: 100%;
    background: ${({isSelected}) => isSelected ? 'rgba(126, 198, 81, 0.7)' : 'rgb(198, 198, 198)'};
    z-index: 1;

    width: 100%;
    transform: scaleX(${({width}) => width / 100});
    transform-origin: center left;
    transition: transform 1.5s ease;
`
```

![img_2.png](img_2.png)

![img_3.png](img_3.png)

저의 경우에는 약 두 배 이상의 성과를 보여줬습니다.
