## 이미지 사이즈 최적화

**이미지 사이즈 기준**

이미지를 사용할 때에는 화면에 표시되는 사이즈보다, 너비 기준으로 두 배 정도 큰 이미지를 사용하는 것이 적절하다.
ex) 화면 표시 사이즈: 120x120px → 사용할 이미지 사이즈: 240x240px

왜? 너무 큰 이미지는 로딩 시간이 오래 걸려서 성능에 좋지 않고, **요즘 사용되는 레티나 디스플레이는 같은 공간(픽셀)에 더 많은 픽셀을 그릴 수 있기 때문에 두 배 정도 큰 이미지가 적절하다.**

<br/>

**이미지 사이즈 줄이는 방법**

- 자체적으로 가지고 있는 정적 이미지 → 사진 편집 툴 이용
- API를 통해 받아오는 이미지 → Cloudinary나 Imgix 같은 이미지 CDN 사용

<br/>

**이미지 CDN**

CDN(Content Delivery Network)이란 물리적 거리의 한계를 극복하기 위해 소비자(사용자)와 가까운 곳에 콘텐츠 서버를 두는 기술을 의미

ex) 미국 서버의 이미지를 한국의 사용자가 사용할 경우
→ 미국에 있는 서버를 미리 한국으로 복사해 두고, 사용자가 이미지를 다운로드 하려고 할 때 미국 서버가 아닌 한국 서버에서 다운로드하도록 하는 것

이미지 CDN은 이미지에 특화된 CDN. 기본적인 CDN 기능과 더불어 이미지를 사용자에게 보내기 전에 특정 형태로 가공하여 전해주는 기능도 제공
ex) 이미지를 줄이거나, 특정 포맷으로 변경하는 작업 등

```html
http://cdn.image.com?src=[img src]&width=240&height=240
```

위의 주소처럼, 이미지 CDN을 자체적으로 만들어서 사용할 수도 있고, 앞서 언급했던 Imgix와 같은 이미지 CDN 솔루션을 사용할 수도 있다.

<br/>
<br/>

## 병목 코드 최적화

**크롬 개발자 도구의 `Performance` 채널**

1. CPU 차트, Network 차트, 스크린샷

- CPU 차트: 시간에 따라 CPU가 어떤 작업에 리소스를 사용하고 있는지 비율로 보여준다. 자바스크립트 실행은 노란색, 렌더링/레이아웃 작업은 보라색, 페인팅 작업은 초록색, 기타 시스템 작업은 회색으로 표시된다.
- Network 차트: 네트워크 상태 표시. 위의 진한 막대는 우선순위가 높은 네트워크를, 아래 옅은 막대는 우선순위가 낮은 네트워크 리소스를 나타낸다.
- 스크린샷: 서비스가 로드되는 과정 표시.

2. Network 타임라인
   Network 타임라인은 서비스 로드 과정에서의 네트워크 요청을 시간 순서에 따라 보여준다.

- 왼쪽 회색 선: 초기 연결 시간
- 막대의 옅은 선 영역: 요청을 보낸 시점부터 응답을 기다리는 시점까지의 시간(TTFB, Time to First Byte)
- 막대의 짙은 선 영역: 콘텐츠 다운로드 시간
- 오르쪽 회색 선: 해당 요청에 대한 메인 스레드의 작업 시간

3. Frame, Timings, Main

- Frame 섹션: 화면의 변화가 있을 때마다 스크린샷을 찍어서 보여준다.
- Timings 섹션: User Timing API를 통해 기록된 정보를 기록한다. 여기 표시된 막대들은 리액트에서 각 컴포넌트의 렌더링 시간을 측정한 것이다.
- Main 섹션: 브라우저의 메인 스레드에서 실행되는 작업을 플레임 차트( Flame chart)로 확인할 수 있다. 이를 통해 어떤 작업이 오래 걸리는지 파악 가능!

4. 하단 탭

- Summary 탭: 선택 영역에서 발생한 작업의 총합과 각 작업이 차지하는 비중을 보여준다.
- Bottom-Up 탭: 가장 최하위에 있는 작업부터 상위 작업까지 역순으로 보여준다.
- Call Tree 탭: Bottom-Up과 반대로 가장 상위 작업부터 하위 작업 순으로 작업 내용을 트리뷰(tree view)로 보여준다.
- Event Log 탭: 발생한 이벤트를 보여준다. 이벤트에는 Loading, Experience Scripting, Rendering, Painting이 있다.

<br/>

**병목 코드 개선**

예시 블로그의 로드 과정을 살펴보면, Timings 섹션의 ArticleList 항목의 실행 시간이 무려 1.4초가 발생한다.
네트워크 시간을 포함하지 않은, 모든 데이터가 준비된 상태에서 렌더링만 하는 것인데 말이다.

메인 스레드의 해당 구간을 확인해보면, `removeSpecialCharacter`이라는 작업이 8.48ms로 Article 컴포넌트의 렌더링 시간이 길어진 이유를 확인해볼 수 있다. 아래에서 이를 개선해보자.

```jsx
/*
 * 파라미터로 넘어온 문자열에서 일부 특수문자를 제거하는 함수
 * (Markdown으로 된 문자열의 특수문자를 제거하기 위함)
 * */
function removeSpecialCharacter(str) {
  const removeCharacters = [
    "#",
    "_",
    "*",
    "~",
    "&",
    ";",
    "!",
    "[",
    "]",
    "`",
    ">",
    "\n",
    "=",
    "-",
  ];
  let _str = str;
  let i = 0,
    j = 0;

  for (i = 0; i < removeCharacters.length; i++) {
    // 비효율_1
    j = 0;
    while (j < _str.length) {
      if (_str[j] === removeCharacters[i]) {
        _str = _str.substring(0, j).concat(_str.substring(j + 1)); // 비효율_2
        continue;
      }
      j++;
    }
  }

  return _str;
}
```

removeCharacters라는 이름으로 제거할 특수 문자를 정의해 두고, 각 특수 문자마다 반복문을 돌려 본문에 일치하는 내용을 탐색한다. 이를 위해 반복문을 중첩해서 사용하고 있고, 문자열을 제거하는 데도 substring과 concat 함수를 이용하고 있다.

**개선**

substring과 concat 함수 => 자바스크립트에는 일치하는 문자를 찾아 제거해주는 replace라는 함수가 이미 존재함. 변경하자

API에서 블로그 글 데이터를 굳이 다 가져올 필요가 있을까? => 블로그 목록을 보여줄 때에는 대략 200자 정도이다. 고로 200자만 잘라서 특수 문자를 제거해보자.

<br/>

```jsx
function removeSpecialCharacter(str) {
  let _str = str.substring(0, 300);
  _str = str.replace(/[#_*~&;![\]`>\n=\->]/g, "");
  return _str;
}
```

=> 최적화 전에는 1.4초 걸리던 작업이, 최적화 후에는 36밀리초로 줄어들었다.

<br/>
<br/>

## 코드 분할 & 지연 로딩

**개념**

**코드 분할(Code Splitting) 기법**은 말 그대로 코드를 분할하는 기법으로, 하나의 번들 파일을 여러 개의 파일로 쪼개는 방법이다. 분할된 코드는 사용자가 서비스를 이용하는 중 해당 코드가 필요해지는 시점에 로드되어 실행되는데, 이를 **지연 로딩**이라고 한다.

코드 분할의 핵심은 ‘불필요한 코드 또는 중복되는 코드 없이 적절한 사이즈의 코드가 적절한 타이밍에 로드되도록 하는 것’이다.

<br/>

**코드 분할 적용**

코드 분할을 하는 가장 좋은 방법은 동적 import를 사용하는 방법이다.

```jsx
import { add } from ‘./math’

console.log(’1 + 4 =’, add(1, 4))
```

위와 같이 했을 때, 해당 모듈은 빌드 시에 함께 번들링이 된다. 하지만 아래와 같이 import문을 사용하면 빌드할 때가 아닌 런타임에 해당 모듈을 로드한다. 이를 동적(dynamic) import라고 한다.

```jsx
import(’add’).then((module) ⇒ {
	const { add } = module

	console.log(’1 + 4 =’, add(1, 4))
})
```

webpack은 동적 import 구문을 만나면 코드를 분할하여 번들링한다.

하지만 동적 import 구문은 promise 형태로 모듈을 반환해준다. 여기서 import 하려는 모듈은 컴포넌트이기 때문에 promise 내부에서 로드된 컴포넌트를 promise 밖으로 빼내야 한다.

→ 이러한 문제를 해결하기 위해, react는 함수 lazy와 Suspense 제공!
→ 이 함수를 이용하면 **비동기 문제를 신경쓰지 않고 간편하게 동적 import를 할 수 있다.**

```jsx
import React, { Suspense } from "react";

const SomeComponent = React.lazy(() => import("./SomeComponent"));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <SomeComponent />
      </Suspense>
    </div>
  );
}
```

lazy 함수는 동적 import를 호출하여 그 결과인 promise를 반환하는 함수를 인자로 받는다. 그렇게 lazy 함수가 반환한 값, 즉 import한 컴포넌트는 Suspense 안에서 렌더링해야 한다.

그래야 동적 import를 하는 동안 컴포넌트가 아직 값을 갖지 못할 때는 Suspense의 fallback prop에 정의된 내용으로 렌더링되고,

이후 컴포넌트가 온전히 로드됐을 때 fallback 값으로 렌더링된 suspense가 정상적으로 컴포넌트로 렌더링 된다.

<br/>
<br/>

## 텍스트 압축

**개념**

텍스트 압축이란 말 그대로 텍스트를 압축하는 것이다. HTML, CSS, JS는 텍스트 기반의 파일이기 때문에 텍스트 압축 기법을 적용할 수 있다.

파일을 압축하여 더 작은 크기로 빠르게 전송한 뒤, 사용하는 시점에 압축을 해제한다. 이때 압축한 만큼 파일의 사이즈가 작아질 테니 리소스를 전송하는 시간도 단축된다.

<br/>

**적용**

압축 여부 확인은 Network의 해당 API 항목을 확인해보면, 응답 헤더(Response Headers)에 `Content-Encoding: gzip` 이라고 되어 있는 것을 볼 수 있다. 이러한 항목이 있지 않다면, 텍스트 압축이 적용되지 않은 상태이다.

책에서는 serve 라이브러리를 사용했기에, 해당 명령어의 u 옵션을 제거해주면 된다. (u 옵션은 텍스트 압축을 하지 않겠다는 의미! )

만약, 다른 서버를 통해 번들 파일을 서비스한다면, 해당 서버에 직접 텍스트 압축 설정을 해야 합니다. 단일 서버가 아니라, 여러 서버를 이용한다면 Nginx와 같은 게이트웨이 서버에 공통적으로 텍스트 압축을 적용할 수 도 있다.
