## 이미지 사이즈 최적화

---

**이미지 사이즈 기준**

이미지를 사용할 때에는 화면에 표시되는 사이즈보다, 너비 기준으로 두 배 정도 큰 이미지를 사용하는 것이 적절하다.

ex) 화면 표시 사이즈: 120x120px → 사용할 이미지 사이즈: 240x240px

왜? 너무 큰 이미지는 로딩 시간이 오래 걸려서 성능에 좋지 않고, **요즘 사용되는 레티나 디스플레이는 같은 공간(픽셀)에 더 많은 픽셀을 그릴 수 있기 때문에 두 배 정도 큰 이미지가 적절하다.**

화소 - 120개

레티나 240개 픽셀 -

**이미지 사이즈 줄이는 방법**

- 자체적으로 가지고 있는 정적 이미지 → 사진 편집 툴 이용
- API를 통해 받아오는 이미지 → Cloudinary나 Imgix 같은 이미지 CDN 사용

**이미지 CDN**

CDN(Content Delivery Network)이란 물리적 거리의 한계를 극복하기 위해 소비자(사용자)와 가까운 곳에 콘텐츠 서버를 두는 기술을 의미

ex) 미국 서버의 이미지를 한국의 사용자가 사용할 경우
→ 미국에 있는 서버를 미리 한국으로 복사해 두고, 사용자가 이미지를 다운로드 하려고 할 때 미국 서버가 아닌 한국 서버에서 다운로드하도록 하는 것

이미지 CDN은 이미지에 특화된 CDN. 기본적인 CDN 기능과 더불어 이미지를 사용자에게 보내기 전에 특정 형태로 가공하여 전해주는 기능도 제공

ex) 이미지를 줄이거나, 특정 포맷으로 변경하는 작업 등

http://cdn.image.com?src=[img src]&width=240&height=240

위의 주소처럼, 이미지 CDN을 자체적으로 만들어서 사용할 수도 있고, 앞서 언급했던 Imgix와 같은 이미지 CDN 솔루션을 사용할 수도 있다.

## 병목 코드 최적화

---

(요약할 내용 다시 확인)

## 코드 분할 & 지연 로딩

---

**개념**

**코드 분할(Code Splitting) 기법**은 말 그대로 코드를 분할하는 기법으로, 하나의 번들 파일을 여러 개의 파일로 쪼개는 방법이다. 분할된 코드는 사용자가 서비스를 이용하는 중 해당 코드가 필요해지는 시점에 로드되어 실행되는데, 이를 **지연 로딩**이라고 한다.

코드 분할의 핵심은 ‘불필요한 코드 또는 중복되는 코드 없이 적절한 사이즈의 코드가 적절한 타이밍에 로드되도록 하는 것’이다.

**코드 분할 적용**

코드 분할을 하는 가장 좋은 방법은 동적 import를 사용하는 방법이다.

```jsx
import { add } from ‘./math’

console.log(’1 + 4 =’, add(1, 4))
```

위와 같이 했을 때, 해당 모듈은 빌드 시에 함께 번들링이 된다. 하지만 아래와 같이 import문을 사용하면 빌드할 때가 아닌 런타임에 해당 모듈을 로드한다. 이를 동적(dynamic) import라고 한다.

```jsx
import(’add’).then((module) ⇒ {
	const { add } = module

	console.log(’1 + 4 =’, add(1, 4))
})
```

webpack은 동적 import 구문을 만나면 코드를 분할하여 번들링한다.

하지만 동적 import 구문은 promise 형태로 모듈을 반환해준다. 여기서 import 하려는 모듈은 컴포넌트이기 때문에 promise 내부에서 로드된 컴포넌트를 promise 밖으로 빼내야 한다.

→ 이러한 문제를 해결하기 위해, react는 함수 lazy와 Suspense 제공!

→ 이 함수를 이용하면 **비동기 문제를 신경쓰지 않고 간편하게 동적 import를 할 수 있다.**

```jsx
//
```

lazy 함수는 동적 import를 호출하여 그 결과인 promise를 반환하는 함수를 인자로 받는다. 그렇게 lazy 함수가 반환한 값, 즉 import한 컴포넌트는 Suspense 안에서 렌더링해야 한다.

그래야 동적 import를 하는 동안 컴포넌트가 아직 값을 갖지 못할 때는 Suspense의 fallback prop에 정의된 내용으로 렌더링되고,

이후 컴포넌트가 온전히 로드됐을 때 fallback 값으로 렌더링된 suspense가 정상적으로 컴포넌트로 렌더링 된다.

## 텍스트 압축

---

**개념**

텍스트 압축이란 말 그대로 텍스트를 압축하는 것이다. HTML, CSS, JS는 텍스트 기반의 파일이기 때문에 텍스트 압축 기법을 적용할 수 있다.

파일을 압축하여 더 작은 크기로 빠르게 전송한 뒤, 사용하는 시점에 압축을 해제한다. 이때 압축한 만큼 파일의 사이즈가 작아질 테니 리소스를 전송하는 시간도 단축된다.

**적용**

압축 여부 확인은 Network의 해당 API 항목을 확인해보면, 응답 헤더(Response Headers)에 `Content-Encoding: gzip` 이라고 되어 있는 것을 볼 수 있다. 이러한 항목이 있지 않다면, 텍스트 압축이 적용되지 않은 상태이다.

책에서는 serve 라이브러리를 사용했기에, 해당 명령어의 u 옵션을 제거해주면 된다. (u 옵션은 텍스트 압축을 하지 않겠다는 의미! )

만약, 다른 서버를 통해 번들 파일을 서비스한다면, 해당 서버에 직접 텍스트 압축 설정을 해야 합니다. 단일 서버가 아니라, 여러 서버를 이용한다면 Nginx와 같은 게이트웨이 서버에 공통적으로 텍스트 압축을 적용할 수 도 있다.
