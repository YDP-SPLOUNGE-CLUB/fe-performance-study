## 이미지 지연 로딩

명확한 흐름을 파악할 수 있도록, 네트워크에 throttling 적용

이번에는 custom 설정을 통해, 업로드와 다운로드 속도를 6000kb/s로 설정.<br/>(참고로 Fast 3G와 Slow 3G 속도보다 느리다.)

<br/>

**🔴 문제**

홈페이지의 메인에는 동영상 배너가 가장 먼저 보이는데, 일부 리소스(스크롤 해야 보이는 아래 이미지들과 폰트)가 다 다운된 후에 동영상이 다운로드 된다.

가장 처음으로 사용자에게 보이는 콘텐츠인데 가장 나중에 로드되면, 사용자 경험에 좋지 않다.

<br/>

**🟢 해결 방법**

동영상의 다운로드를 방해하는, 당장 사용되지 않는 이미지를 나중에 다운되도록 하는 것이다. 즉, 이미지를 지연 로드 하는 것!

**그럼 이미지는 언제 로드되어야 할까?**<br/>
=> 바로 이미지가 화면에 보이는 순간 또는 그 직전에 이미지를 로드해야 한다.

다시 말해, 뷰포트에 이미지가 표시될 위치까지 스크롤되었을 때, 이미지를 로드할지 말지 판단!

**스크롤 이벤트를 사용하면 되려나?** <br/>
=> 놉! 스크롤 이벤트에 이미지를 보이게 할지말지 판단하는 로직을 넣으면, 오히려 성능을 악화시킬 수도 있다. 왜냐하면, 스크롤을 이동하는 중에 계속 이벤트가 발생하기 때문~.~

<br/>

### Intersection Observer를 사용하자.

이는 브라우저에서 제공하는 api로, 웹페이지의 특정 요소를 관찰(observe)하면 페이지 스크롤 시, 해당 요소가 화면에 들어왔는지 아닌지 알려준다.
<br/>
즉, 스크롤 이벤트처럼 스크롤 할 때마다 함수를 호출하는 것이 아니라 요소가 화면에 들어왔을 때만 함수를 호출하는 것이다.

<br/>

**Intersection Observer의 옵션들**

- root: 대상 객체의 가시성을 확인할 때 사용되는 뷰포트 요소.
- rootMargin: root 요소의 여백. root의 가시 범위를 확장/축소하는 역할
- threshold: 가시성 퍼센티지. 대상 요소가 어느 정도로 보일 때 콜백을 실행할지 결정한다.<br/> `1.0`으로 설정하면, 대상 요소가 모두 보일 때 실행되며, `0`은 1px이라도 보이는 경우 콜백이 실행됨
- callback: 가시성이 변경될 때마다 실행되는 함수

<br/>

### Intersection Observe 적용하기

```jsx
fuction Card(props) {
    const imgRef = useRef(null)

    useEffect(() => {
      const options = {};
      const callback = (entries, observer) => {
        console.log("Entries", entries);
      };
      const observer = new IntersectionObserver(callback,   options);

      observer.observe(imgRef.current);

      return () => sberver.disconnect();
    }, []);

    return (
        <div claseName='Card text-center'>
            <img src={props.image} ref={imgRef} />
            <div className='생략'>{props.children}</div>
        </div>
    );
}
```

**useEffect 안에서 Intersection Observe 생성한 이유**

useEffect를 사용하지 않으면, 렌더링할 때마다 인스턴스가 생성되고, 대상 요소를 관찰하게 되면서 대상 요소에 여러 개의 콜백이 실행된다.

따라서, 이와 같은 중복을 방지하고자, useEffect에서 인스턴스를 생성해야 한다. 또한 생성된 인스턴스는 정리(clean-up) 함수에서 `observer.disconnect` 함수를 호출함으로써 리소스가 낭비되지 않도록 해야한다.

<br/>

위에서 console.log로 entries값을 확인해보면, 다양한 정보를 가지고 있다. 그 중에서도 가장 중요한 값은 바로, `isIntersecting`이라는 값이다.

이 값은 해당 요소가 뷰포트 내에 들어왔는지를 나타내는 값으로, 해당 요소가 화면에 보이는 것인지, 화면에서 나가는 것인지 불리언 값으로 알려준다.

<br/>

### 콜백이 실행되는 순간에 이미지 로드하기

이미지 로딩은 img 태그에 src가 할당되는 순간 일어난다. <br/>따라서 최초에는 img 태그에 src 값을 할당하지 않다가 콜백이 실행되는 순간 src를 할당함으로써 이미지 지연 로딩을 적용할 수 있다.

```jsx
fuction Card(props) {
    const imgRef = useRef(null)

    useEffect(() => {
        const options = {}
        const callback = (entries, observer) => {
            entries.forEach((entry) => {
                if (entry.isIntersecting) {
                entry.target.src = entry.target.dataset.src;
                observer.unobserve(entry.target);
                }
            })
        }

        const observer = new IntersectionObserver(callback,   options);

        observer.observe(imgRef.current);
        return () => sberver.disconnect();
    } , []);

    return (
        <div claseName='Card text-center'>
            <img data-src={props.image} ref={imgRef} />
            <div className='생략'>{props.children}</div>
        </div>
    );
}
```

먼저 img 태그의 속성을 보면 원래 src에 넣었던 이미지 주소(props.image)를 이제는 `data-src`에 넣었다.

이렇게 하면, src 값이 할당되지 않기 때문에 해당 이미지를 로드하지 않는다. 그리고 data-src에 주소를 넣음으로써, 나중에 이미지가 뷰포트에 들어왔을 때, data-src에 있는 값을 src로 옮겨 이미지를 로드할 수 있다.

<br/>

`observer.unobserve(entry.target)` 코드는 해당 요소의 observe를 해제하는 코드이다. 한 번 이미지를 로드한 후에는 다시 호출할 필요가 없으므로 해제하는 것이다.

<br/>

## 이미지 사이즈 최적화

**🔴 문제**

지연로딩을 적용하기 전에는 처음부터 이미지를 다운로드했기 때문에 스크롤을 내려도 거의 바로 로드된 이미지를 볼 수 있었다.

지금은 스크롤이 이미지 위치에 도달하는 순간 로드하기 때문에 바로 전체 이미지가 보이지 않고 천천히 로드된다.

이렇게 이미지가 잘려보이면 서비스가 느리다는 느낌을 줄 수 있다.

<br/>

**🟢 해결 방법**

Network 패널을 통해 이 이미지들을 살펴보면, 파일의 크기가 매우 큰 것을 볼 수 있다. 이렇게 이미지 사이즈가 크면 다운로드에 많은 시간이 걸리고 그만큼 다른 작업에 영향을 줄 수 있다.

이번에는 이미지 사이즈 최적화를 통해 문제를 해결해보자.

<br/>

### 이미지 포맷 종류

이미지 사이즈 최적화는 간단히 말하면 이미지의 가로, 세로 사이즈를 줄여 이미지 용량을 줄이고 그만큼 더 빠르게 다운로드하는 기법이다.

이미지를 잘 다루기 위헤 짚고 넘어가야 할 것이 바로 이미지 포맷이다. 그중 SVG와 같은 벡터 이미지가 아닌 비트맵 이미지 포맷 중 대표적인 세 가지 포맷을 살펴보자.

- **PNG:** 무손실 압축 방식으로 원본을 훼손 없이 압축하며 알파 패널을 지원하는 이미지 포맷.<br/>알파 채널이란 투명도를 의미. PNG 포맷으로 배경 색을 투명하게 하여 뒤에 있는 요소가 보이는 이미지를 만들 수 있다.

<br/>

- **JPG:** PNG와 다르게 압축 과정에서 정보 손실이 발생한다. 하지만 그만큼 이미지를 더 작은 사이즈로 줄일 수 있다. <br/> 그래서 일반적으로 웹에서 이미지를 사용할 때는 고화질이어야 하거나 투명도 정보가 필요한 게 아니라면 JPG 사용.

<br/>

- **WebP:** 무손실 압축과 손실 압축을 모두 제공하는 이미지 포맷. 기존의 PNG나 JPG에 비해 대단히 효율적으로 이미지를 압축할 수 있다.<br/>
  하지만 꽤나 최신 이미지 포맷(2010년..ㅋ)이라서 아직 지원하지 않는 브라우저도 있다. 브라우저 호환성 문제가 살짝 있다!

<br/>

✨ 정리해보자면... ✨

**사이즈: PNG > JPG > WebP**

**화질: PNG = WebP > JPG**

**호환성: PNG = JPG > WebP**

<br/>

### Squoosh를 사용하여 이미지 변환

: 구글에서 만든 이미지 컨버터 웹 어플리케이션으로, 별도의 프로그램 설치없이 웹에서 이미지를 손쉽게 여러 가지 포맷으로 변환할 수 있다.

책에서는 Edit 섹션의 Resize 설정과 Compress 섹션에 있는 설정만 이용

화면의 보이는 이미지 사이즈가 `300X300px`이므로 그 두배인, `600X600px`으로 Resize 설정.

Compress 섹션의 압축 방식과 압축률(Quality)을 각각 WebP, 75로 설정한다. (이 값이 너무 작으면 화질이 많이 떨어지고, 너무 크면 용량이 커지므로 70~80이 적당하다고 한다.)

그 외 Effort 설정이 있는데, 이 값은 CPU의 리소스를 어느 정도로 사용할지에 대한 설정이다. 책에서는 기본 값인 4!

<br/>

### WebP의 호환성 문제 해결

picture 태그를 사용하자. 이 태그는 다양한 타입의 이미지를 렌더링하는 컨테이너로 사용된다.

브라우저에서 변환한 WebP 이미지를 지원하지 않는 경우를 대비해 picture 태그 사용하여 JPG 이미지 렌더링되도록 할 것이다.

```JSX
<picture>
    <source data-srcset={props.webp} type="image/webp" />
    <img data-src={props.image} ref={imgRef} />,
</picture>
```

위의 코드처럼 하면, 가장 상위에 있는 WebP을 우선으로 로드하고, 브라우저가 지원하지 않으면 img 태그에 있는 JPG 이미지를 렌더링한다.

<br/>

## 동영상 사이즈 최적화

**🔴 문제**

Network 패널 기록에서도 볼 수 있듯이 동영상 파일은 이미지처럼 하나의 요청으로 모든 영상을 다운로드하지 않는다.

동영상 콘텐츠의 특성상 파일 크기가 크기 때문에 당상 재생이 필요한 앞부분부터 먼저 다운로드한 뒤 순차적으로 나머지 내용을 다운로드 한다.

그러나 이렇게 해도, 파일 자체가 크다보니, 동영상을 재생하기까지 너무 오래걸린다..

<br/>

**🟢 해결 방법**

이미지 최적화와 비슷하게, 동영상의 가로와 세로 사이즈를 줄이고, 압축 방식을 변경하여 동영상의 용량을 줄일 수 있다.

주의해야 할 점은 동영상을 압축하는 작업은 `화질을 낮추는 작업`이라는 것이다.

때문에 동영상이 서비스의 메인콘텐츠라면 추천하지 않는다.

`Media.io`라는 서비스를 이용하여 WepM 확장자로 변환 <br/> => WebM은 WebP와 마찬가지로 구글에서 개발한 동영상 포맷이다.

<br/>

### 압축된 동영상 적용

이미지 최적화와 마찬가지로, WepM 파일을 지원하지 않는 브라우저를 위해 video 태그를 사용하여 아래와 같이 코드를 작성한다.

```jsx
<video className="생략" autoPlay loop muted>
  <source src={video_webm} type="video/webm" />
  <source src={video} type="video/mp4" />
</video>
```

이렇게 하면, WebM 동영상을 지원하지 않는 브라우저에서는 그다음 소스인 MP4 동영상으로 재생한다.

<br/>

### 저하된 화질을 보완할 수 있는 방법

동영상 위에 패턴을 넣거나 필터를 씌우는 방법이 있다.

무수히 많은 점을 찍는 패턴 기법을 이용하여 보완하거나 이것으로 부족하다면 필터를 적용하면 된다.

다양한 필터 중 `blur`가 가장 효과적이다.

video 요소에 css 코드로 `filter: blur(10px)`를 넣어 주면 동영상이 흐려진다. 배경으로 가볍게 사용할 때 효과적이다.

<br/>

## 캐시 최적화

### 캐시란?

캐시는 간단히 말하면 자주 사용하는 데이터나 값을 미리 복사해 둔 임시 저장 공간 또는 저장하는 동작이다.

웹에서는 서비스에서 사용하는 이미지나 자바스크립트 파일을 매번 네트워크를 통해 불러오지 않고, 최초에만 다운로드하여 캐시에 저장해두고 그 이후 요청 시에는 저장해 둔 파일을 사용한다.

**캐시의 종류**

- **메모리 캐시**: 메모리에 저장하는 방식. 여기서 메모리는 RAM을 의미
- **디스크 캐시**: 파일 형태로 디스크에 저장하는 방식

웹에서 사용하는 캐시는 위와 같이 크게 두 가지로 구분할 수 있다.

어떤 캐시를 사용할지는 직접 제어할 수 없고, **브라우저가** 사용 빈도나 파일 크기에 따라 특정 알고리즘에 의해 **알아서 처리한다.**

캐시가 적용된 리소스를 확인해보면, 응답헤더에 `Cache-Control`이라는 헤더가 들어있다. 이 헤더는 서버에서 설정되며, 이를 통해 브라우저는 해당 리소스를 얼마나 캐시할지 판단한다.

<br/>

### Cache-Control

Cache-Control은 리소스의 응답 헤더에 설정되는 헤더이다. 브라우저는 서버에서 이 해더를 통해 캐시를 어떻게, 얼마나 적용해야하는지 판단한다.

Cache-Control에는 대표적으로 아래 5가지의 값이 조합되어 들어간다.

- **no-cache:** 캐시를 사용하기 전 서버에 검사 후 사용
- **no-store:** 캐시 사용 안 함
- **public:** 모든 환경에서 캐시 사용 가능
- **private:** 브라우저 환경에서만 캐시 사용, 외부 캐시 서버에서는 사용 불가
- **max-age:** 캐시의 유효 시간

public과 private로 설정하면, max-age에서 설정한 시간만큼은 서버에 사용 가능 여부를 묻지 않고, 캐시된 리소스를 바로 사용한다.

만약 유효 시간이 지났다면 서버에 캐시된 리소스를 사용해도 되는지 다시 체크하고 유효 시간만큼 더 사용한다.

<br/>

### 캐시 적용

리액트는 서버가 아니므로 캐시 설정을 할 수 있도록 간단한 노드 서버로 테스트 해보자.

```javascript
const header = {
  setHeader: (res, path) => {
    res.setHeader("Cache-Control", "max-age=10");
  },
};
```

코드 수정 후, 실행 중인 서버를 종료하고 다시 실행하면, Network 패널에서 리소스들이 캐시되는 것을 볼 수 있다.

이때의 `status code`는 `200 OK`

10초가 지난 후, 세로고침을 하면 기록이 조금 다르게 저장된다.

이는 캐시 유효 시간이 만료되면서 브라우저가 기존의 캐시된 리소스를 그대로 사용해도 될지 서버에 확인하기 때문이다.

책에서는 서비스의 리소스가 변경되지 않아, 그대로 사용해도 무방하기에 서버는 변경되지 않았다는 `304` 상태 코드를 응답으로 보내줬다.

<br/>

### 적절한 캐시 유효 시간

앞에서 진행한 방식은 모든 리소스에 동일한 캐시 설정이 적용되기 때문에 효율적이지는 않다.

왜냐하면 리소스마다 사용이나 변경 빈도가 달라 캐시의 유효 시간도 달라져야 하기 때문이다.

**일반적으로 HTML 파일에는 no-cache 설정을 적용한다.**
<br/>
=> 항상 최신 버전의 웹서비스를 제공하기 위해서이다.

하지만 자바스크립트와 CSS 파일은 조금 다르다. 빌드된 자바스크립트와 CSS는 파일명에 해시를 함께 가지고 있다. ex) main.bb8aac29.chunk.js
<br/>
즉 코드가 변경되면 해시도 변경되어 완전히 다른 파일이 되어 버린다.

**따라서 캐시를 아무리 오래 적용해도 HTML 파일만 최신 상태라면 자바스크립트나 CSS 파일은 당연히 최신 리소스를 로드할 것이다.**

<br/>

<br/>

## 불필요한 CSS 제거

### PurgeCSS

PurgeCSS는 파일에 들어 있는 모든 키워드를 추출하여 해당 키워드를 이름으로 갖는 CSS 클래스만 보존하고 나머지 매칭되지 않은 클래스는 모두 지우는 방식으로 CSS 파일을 최적화한다.
